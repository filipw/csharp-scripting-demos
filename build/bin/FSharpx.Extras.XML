<?xml version="1.0" encoding="utf-8"?>
<doc>
<assembly><name>FSharpx.Extras</name></assembly>
<members>
<member name="T:FSharpx.Cont`2">
<summary>
 The continuation monad.
 The algorithm is from Wes Dyer http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
 Current implementation from Matt&apos;s gist at https://gist.github.com/628956
</summary>
</member>
<member name="T:FSharpx.Coroutine">
<summary>
 The coroutine type from http://fssnip.net/7M
</summary>
</member>
<member name="M:FSharpx.FSharpAsyncEx.Protect``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Encapsulates any possible exceptions during bind in a Choice
</summary>
</member>
<member name="M:FSharpx.FSharpAsyncEx.IgnoreResult``1(Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Ignores (discards) the result of the async computation
</summary>
</member>
<member name="M:FSharpx.FSharpChoice.Value``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw ArgumentException.
</summary>
</member>
<member name="M:FSharpx.FSharpChoice.Cast``1(System.Object)">
<summary>
 Attempts to cast an object.
 Stores the cast value in 1Of2 if successful, otherwise stores the exception in 2Of2
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``3(System.Func{``0,``1,``2})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``2(System.Func{``0,``1})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromFunc``1(System.Func{``0})">
<summary>
 Convert a Func into an F# function
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``3(System.Action{``0,``1,``2})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``2(System.Action{``0,``1})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction``1(System.Action{``0})">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="M:FSharpx.FSharpFunc.FromAction(System.Action)">
<summary>
 Convert an Action into an F# function returning unit
</summary>
</member>
<member name="T:FSharpx.FSharpFunc">
 <summary>
 Conversion functions from Action/Func to FSharpFunc
 We need these because FuncConvert often makes C# type inference fail.
 </summary>
</member>
<member name="M:FSharpx.FSharpOption.Where``1(Microsoft.FSharp.Core.FSharpOption{``0},System.Predicate{``0})">
<summary>
 Applies a predicate to the option. If the predicate returns true, returns Some x, otherwise None.
</summary>
</member>
<member name="M:FSharpx.FSharpOption.ToFSharpList``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts the option to a list of length 0 or 1
</summary>
</member>
<member name="M:FSharpx.FSharpOption.ToArray``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Converts the option to an array of length 0 or 1
</summary>
</member>
<member name="M:FSharpx.FSharpOption.SelectMany``3(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,Microsoft.FSharp.Core.FSharpOption{``1}},System.Func{``0,``1,``2})">
<summary>
 Invokes a function on an optional value that itself yields an option,
 and then applies a mapping function
</summary>
</member>
<member name="M:FSharpx.FSharpOption.SelectMany``2(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Invokes a function on an optional value that itself yields an option
</summary>
</member>
<member name="M:FSharpx.FSharpOption.Select``2(Microsoft.FSharp.Core.FSharpOption{``0},System.Func{``0,``1})">
<summary>
 Transforms an option value by using a specified mapping function
</summary>
</member>
<member name="M:FSharpx.FSharpOption.OrElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the option if Some x, otherwise the supplied default value.
</summary>
</member>
<member name="M:FSharpx.FSharpOption.Aggregate``2(Microsoft.FSharp.Core.FSharpOption{``0},``1,System.Func{``1,``0,``1})">
 <summary>
 Evaluates the equivalent of <see cref="System.Linq.Enumerable.Aggregate"/> for an option
 </summary>
</member>
<member name="M:FSharpx.Funcs.Untuple``4(System.Action{System.Tuple{``0,``1,``2,``3}})">
<summary>
 Converts an action taking a 4-tuple into an action with 4 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Untuple``3(System.Action{System.Tuple{``0,``1,``2}})">
<summary>
 /// Converts an action taking a 3-tuple into an action with 3 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Untuple``2(System.Action{System.Tuple{``0,``1}})">
<summary>
 Converts an action taking a 2-tuple into an action with 2 parameters
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``4(System.Action{``0,``1,``2,``3})">
<summary>
 Converts an action with 4 arguments into an action taking a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``3(System.Action{``0,``1,``2})">
<summary>
 Converts an action with 3 arguments into an action taking a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.Tuple``2(System.Action{``0,``1})">
<summary>
 Converts an action with 2 arguments into an action taking a 2-tuple
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``3(System.Action{``0,``1,``2})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``2(System.Action{``0,``1})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc``1(System.Action{``0})">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.ToFunc(System.Action)">
<summary>
 Converts an action to a function returning Unit
</summary>
</member>
<member name="M:FSharpx.Funcs.Curry``4(System.Func{``0,``1,``2,``3})">
<summary>
 Converts an uncurried function to a curried function
</summary>
</member>
<member name="M:FSharpx.Funcs.Curry``3(System.Func{``0,``1,``2})">
<summary>
 Converts an uncurried function to a curried function
</summary>
</member>
<member name="M:FSharpx.Funcs.Compose``3(System.Func{``0,``1},System.Func{``2,``0})">
<summary>
 Composes two functions.
 Mathematically: f . g
</summary>
</member>
<member name="M:FSharpx.Funcs.AndThen``3(System.Func{``0,``1},System.Func{``1,``2})">
<summary>
 Composes two functions (forward composition).
 Mathematically: g . f
</summary>
</member>
<member name="T:FSharpx.Funcs">
<summary>
 Extensions around Actions and Funcs
</summary>
</member>
<member name="M:FSharpx.ISemigroup`1.Combine(`0,`0)">
 <summary>
 Associative operation
 </summary>
</member>
<member name="T:FSharpx.ISemigroup`1">
<summary>
 Semigroup (set with associative binary operation)
</summary>
</member>
<member name="M:FSharpx.L.F``3(System.Func{``0,``1,``2})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``2(System.Func{``0,``1})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.L.F``1(System.Func{``0})">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="T:FSharpx.L">
<summary>
 Helps the C# compiler with Func type inference.
</summary>
</member>
<member name="M:FSharpx.Monoid`1.Zero">
 <summary>
 Identity
 </summary>
</member>
<member name="M:FSharpx.Monoid`1.Concat(System.Collections.Generic.IEnumerable{`0})">
<summary>
 Fold a list using this monoid
</summary>
</member>
<member name="M:FSharpx.Monoid`1.Combine(`0,`0)">
<summary>
 Associative operation
</summary>
</member>
<member name="T:FSharpx.Monoid`1">
<summary>
 Monoid (associative binary operation with identity)
</summary>
</member>
<member name="M:FSharpx.Async.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Control.FSharpAsync{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterDot``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequentially compose two async actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiply``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_MultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Async.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Async.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Async.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Transforms an async value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Async.pipe``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Flipped map
</summary>
</member>
<member name="M:FSharpx.Async.ap``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_LessMultiplyGreater``2(Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Async.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Async.op_GreaterGreaterEquals``2(Microsoft.FSharp.Control.FSharpAsync{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Async.returnM``1(``0)">
<summary>
 Inject a value into the async type
</summary>
</member>
<member name="M:FSharpx.Async.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Control.FSharpAsync{``1}},Microsoft.FSharp.Control.FSharpAsync{``0})">
<summary>
 Sequentially compose two actions, passing any value produced by the second as an argument to the first.
</summary>
</member>
<member name="M:FSharpx.Choice.ofOption``2(``0,Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 If Some value, returns Choice1Of2 value. Otherwise, returns the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Choice.toOption``2">
<summary>
 If Choice is 1Of2, returns Some value. Otherwise, returns None.
</summary>
</member>
<member name="M:FSharpx.Choice.mapSecond``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Transforms a Choice&apos;s second value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.choice``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.bimap``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``3},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Maps both parts of a Choice.
 Applies the first function if Choice is 1Of2.
 Otherwise applies the second function
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpChoice{``3,``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Choice.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Choice.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``2,``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Choice.bind``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpChoice{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Choice.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``2,``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Choice.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,``3},Microsoft.FSharp.Core.FSharpChoice{``1,``3})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Choice.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Transforms a Choice&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Choice.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2},Microsoft.FSharp.Core.FSharpChoice{``0,``2})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,``1},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Choice.cast``1(System.Object)">
<summary>
 Attempts to cast an object.
 Stores the cast value in 1Of2 if successful, otherwise stores the exception in 2Of2
</summary>
</member>
<member name="M:FSharpx.Choice.protect``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Wraps a function, encapsulates any exception thrown within to a Choice
</summary>
</member>
<member name="M:FSharpx.Choice.getOrRaise``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw the exception in 2Of2.
</summary>
</member>
<member name="M:FSharpx.Choice.get``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 If Choice is 1Of2, return its value.
 Otherwise throw ArgumentException.
</summary>
</member>
<member name="M:FSharpx.Choice.returnM``2(``0)">
<summary>
 Inject a value into the Choice type
</summary>
</member>
<member name="M:FSharpx.Collections.List.monoid``1">
<summary>
 List monoid
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``3,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequentially compose two continuation actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3},``3}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``3},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``3},``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Transforms a Cont value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.ap``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``1,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``2},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``2},``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``2,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{System.Exception,``1},``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.ContinuationModule.returnM``2(``0)">
<summary>
 Inject a value into the Cont type
</summary>
</member>
<member name="T:FSharpx.Functional.Enumeratee`3">
<summary>
 An enumeratee is an enumerator that produces an iteratee using another iteratee as input.
 Enumeratees can be used for tasks such as encoding or encrypting data.
</summary>
</member>
<member name="T:FSharpx.Functional.Enumerator`2">
<summary>
 An enumerator generates a stream of data and feeds an iteratee, returning a new iteratee.
</summary>
</member>
<member name="T:FSharpx.Functional.Iteratee`2">
<summary>
 The iteratee is a stream consumer that will consume a stream of data until either 
 it receives an EOF or meets its own requirements for consuming data. The iteratee
 will return Continue whenever it is ready to receive the next chunk. An iteratee
 is fed data by an Enumerator, which generates a Stream. 
</summary>
</member>
<member name="T:FSharpx.Functional.Stream`1">
<summary>
 A stream of chunks of data generated by an Enumerator.
 The stream can be composed of chunks of &apos;T, empty blocks indicating a wait, or an EOF marker.
 Be aware that when using #seq&lt;_&gt; types, you will need to check for both Seq.empty ([]) and Empty.
</summary>
</member>
<member name="M:FSharpx.Functional.Enumerator.scanUntil``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state until the provided predicate is true.
</summary>
</member>
<member name="M:FSharpx.Functional.Enumerator.scanWhile``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state while the provided predicate is true.
</summary>
</member>
<member name="M:FSharpx.Functional.Enumerator.scan``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Collections.Generic.IEnumerator{``1})">
<summary>
 Scan progressively folds over the enumerator, returning a new enumerator
 that lazily computes each state.
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,FSharpx.Functional.Iteratee{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,FSharpx.Functional.Iteratee{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``2,FSharpx.Functional.Iteratee{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_GreaterGreaterDot``3(FSharpx.Functional.Iteratee{``0,``1},FSharpx.Functional.Iteratee{``0,``2})">
<summary>
 Sequentially compose two iteratee actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_LessMultiply``3(FSharpx.Functional.Iteratee{``0,``1},FSharpx.Functional.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_MultiplyGreater``3(FSharpx.Functional.Iteratee{``0,``1},FSharpx.Functional.Iteratee{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.ap``3(FSharpx.Functional.Iteratee{``0,``1},FSharpx.Functional.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Functional.IterateeModule.op_LessMultiplyGreater``3(FSharpx.Functional.Iteratee{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},FSharpx.Functional.Iteratee{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.listToArray``2(FSharpx.Functional.Lens{``0,Microsoft.FSharp.Collections.FSharpList{``1}})">
<summary>
 Converts a lens that views a list into a lens that views an array
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.xmap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``0},FSharpx.Functional.Lens{``2,``0})">
<summary>
 Applies an isomorphism to the value viewed through a lens
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.seqMap``2(FSharpx.Functional.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a sequence
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.arrayMap``2(FSharpx.Functional.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in an array
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.listMap``2(FSharpx.Functional.Lens{``0,``1})">
<summary>
 Creates a lens that maps the given lens in a list
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.forList``1(System.Int32)">
<summary>
 Lens for a particular position in a list
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.forArray``1(System.Int32)">
<summary>
 Lens for a particular position in an array
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.forMap``2(``0)">
<summary>
 Lens for a particular key in a map
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.forSet``1(``0)">
<summary>
 Lens for a particular value in a set
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.id``1">
<summary>
 Identity lens
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.snd``2">
<summary>
 Gets/sets the snd element in a pair
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.fst``2">
<summary>
 Gets/sets the fst element in a pair
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.modifyAndGetState``2(FSharpx.Functional.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the modified value.
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.getAndModifyState``2(FSharpx.Functional.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1})">
<summary>
 Modifies the state in a state monad and returns the original value.
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.updateState``2(FSharpx.Functional.Lens{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,``1},``0)">
<summary>
 Update through a lens within a state monad
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.setState``2(FSharpx.Functional.Lens{``0,``1},``1,``0)">
<summary>
 Applies a lens in the &apos;set&apos; direction within a state monad
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.getState``2(FSharpx.Functional.Lens{``0,``1},``0)">
<summary>
 Applies a lens in the &apos;get&apos; direction within a state monad      
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.cond``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},FSharpx.Functional.Lens{``0,``1},FSharpx.Functional.Lens{``0,``1})">
 <summary>
 <paramref name="pred"/> is applied to source. 
 If true, <paramref name="lensTrue"/> is selected.
 If false, <paramref name="lensFalse"/> is selected.
 </summary>
</member>
<member name="M:FSharpx.Functional.LensModule.pair``4(FSharpx.Functional.Lens{``0,``1},FSharpx.Functional.Lens{``2,``3})">
<summary>
 Pair two lenses
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.choice``3(FSharpx.Functional.Lens{``0,``1},FSharpx.Functional.Lens{``2,``1})">
<summary>
 Composes two lenses through a sum in the source
</summary>
</member>
<member name="M:FSharpx.Functional.LensModule.compose``3(FSharpx.Functional.Lens{``0,``1},FSharpx.Functional.Lens{``2,``0})">
<summary>
 Sequentially composes two lenses
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.op_BarGreaterBang``2(``0,Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Custom operator for `tee`: Given a value, apply a function to it, ignore the result, then return the original value.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tee``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},``0)">
<summary>
 Given a value, apply a function to it, ignore the result, then return the original value.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.undefined``1">
<summary>
 Bottom value
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.op_Concatenate``2">
<summary>
 Sequencing operator like Haskell&apos;s ($). Has better precedence than (&lt;|) due to the
 first character used in the symbol.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.fix3``4(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}}},``0,``1,``2)">
<summary>
 Fixed point combinator.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.fix2``3(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}}},``0,``1)">
<summary>
 Fixed point combinator.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.fix``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``1}},``0)">
<summary>
 Fixed point combinator.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple6``6(``0,``1,``2,``3,``4,``5)">
<summary>
 Creates a 6-tuple
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple5``5(``0,``1,``2,``3,``4)">
<summary>
 Creates a 5-tuple
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple4``4(``0,``1,``2,``3)">
<summary>
 Creates a 4-tuple
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple3``3(``0,``1,``2)">
<summary>
 Creates a 3-tuple
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.tuple2``2(``0,``1)">
<summary>
 Creates a pair
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.konst2``3(``0,``1,``2)">
<summary>
 Given a value, creates a function with two ignored arguments which returns the value.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.konst``2(``0,``1)">
<summary>
 Given a value, creates a function with one ignored argument which returns the value.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.swap``2(``0,``1)">
<summary>
 Swap the elements of a pair.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.uncurry3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``0,``1,``2)">
<summary>
 Transforms an uncurried function to a triple-curried function.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.curry3``4(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1,``2},``3},``0,``1,``2)">
<summary>
 Transforms an uncurried function to a triple-curried function.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.uncurry``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``0,``1)">
<summary>
 Transforms an uncurried function to a curried function.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.curry``3(Microsoft.FSharp.Core.FSharpFunc{System.Tuple{``0,``1},``2},``0,``1)">
<summary>
 Transforms an uncurried function to a curried function.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.flip4``5(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``3,``4}}}},``1,``2,``3,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.flip3``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,``3}}},``1,``2,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:FSharpx.Functional.Prelude.flip``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},``1,``0)">
<summary>
 Transforms a function by flipping the order of its arguments.
</summary>
</member>
<member name="M:FSharpx.Http.Conneg.bestCharset(Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Intersects accepted and served charsets.
 Returns the preferred viable charset, or <c>None</c>.
 </summary>
 <param name="x"></param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiateCharset(Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Intersects accepted and served charsets. 
 Returns a list of viable charsets, sorted by client preference in descending order
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.matchCharset(System.String,System.String)">
 <summary>
 Matches two charset tags
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.bestLanguage(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Intersects accepted and served media.
 Returns the preferred viable language, or <c>None</c>.
 </summary>
 <param name="x"></param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiateLanguage(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Intersects accepted and served languages. 
 Returns a list of viable languages, sorted by client preference in descending order
 </summary>
 <param name="x"></param>
</member>
<member name="M:FSharpx.Http.Conneg.matchLanguage(System.String,System.String)">
 <summary>
 Matches two language tags
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.|AcceptsMedia|_|(System.String,Microsoft.FSharp.Collections.FSharpList{System.String})">
 <summary>
 Matches if the media parameter can be handled by the accept list
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.bestMediaType(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Intersects accepted and served media.
 Returns the preferred viable media, or <c>None</c>.
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.bestOf``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Collections.FSharpList{``2}}},``0,``1)">
 <summary>
 Gets the first item from a list of negotiated items
 </summary>
 <param name="negotiate"></param>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiateMediaType(System.Collections.Generic.IEnumerable{System.String})">
 <summary>
 Intersects accepted and served media. 
 Returns a list of viable media, sorted by client preference in descending order
 </summary>
 <param name="serves">Served media</param>
 <param name="accepts">Accept header</param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiate``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{System.String,Microsoft.FSharp.Core.FSharpOption{``1}}},System.Collections.Generic.IEnumerable{``0},System.String)">
 <summary>
 Filters and maps a list of served items and a Accept-* header of acceptable items using a matcher function
 </summary>
 <param name="matcher"></param>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.negotiateList``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{System.Tuple{``2,``3}}}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
 <summary>
 Filters and maps two sequences of items using a matcher function.
 </summary>
 <param name="matcher"></param>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.matchMediaType(System.String,System.String)">
 <summary>
 Finds a match between two media types, handling wildcards.
 Returns <c>None</c> if no match, otherwise <c>Some media</c>
 Example: <c>matchMediaType "text/*" "text/plain"</c> -> <c>"text/plain"</c>
 </summary>
 <param name="serves"></param>
 <param name="accepts"></param>
</member>
<member name="M:FSharpx.Http.Conneg.filterMediaTypes(System.String,System.String)">
 <summary>
 Filters an Accept header by type.
 E.g. <c>filterMediaTypes "image" "image/png,text/html"</c> -> <c>["image/png"]</c>
 </summary>
 <param name="mediaType"></param>
 <param name="accepts"></param>
</member>
<member name="P:FSharpx.Http.Conneg.parseMediaTypes">
 <summary>
 Parses an Accept header into a list of media,(media type, media subtype),q
 E.g. "text/html",("text","html"),0.8
 </summary>
</member>
<member name="M:FSharpx.Http.Conneg.splitMediaTypeSubtype(System.String)">
 <summary>
 Splits media type and subtype, e.g. "text/html" -> "text","html"
 </summary>
 <param name="m"></param>
</member>
<member name="P:FSharpx.Http.Conneg.parseFilterSortAccept">
 <summary>
 Parses any Accept-* header. 
 Removes all items with q=0 (i.e. not acceptable by client).
 Sorts by q descending (client preference)
 </summary>
</member>
<member name="P:FSharpx.Http.Conneg.filterSortAccept">
 <summary>
 Takes a list of items with associated numeric quality (preference), and:
 removes all items with q=0 (i.e. not acceptable by client);
 sorts by q descending (client preference)
 </summary>
</member>
<member name="P:FSharpx.Http.Conneg.parseAccept">
 <summary>
 Parses any Accept-* header, returns a seq of items with associated q (quality/preference)
 </summary>
</member>
<member name="M:FSharpx.Http.Conneg.parseQ(System.String[])">
 <summary>
 Parses a single Accept-* header item. 
 Returns item with associated q
 </summary>
 <param name="s">Header item split by ';'</param>
</member>
<member name="M:FSharpx.IO.IOPrimitives.combinePaths(System.String,System.String)">
<summary>
 Combines two path strings
</summary>
</member>
<member name="P:FSharpx.IO.IOPrimitives.directorySeparator">
<summary>
 The directory separator string. On most systems / or \
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendFileNamesIfNotNull(System.Collections.Generic.IEnumerable{System.String},System.Text.StringBuilder)">
<summary>
 Appends all notnull fileNames
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendStringIfValueIsNotNullOrEmpty(System.String)">
<summary>
 Appends a text if the value is not null or empty
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendStringIfValueIsNotNull``1(``0)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendIfNotNull``1(``0,System.String)">
<summary>
 Appends a text if the value is not null
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendIfFalse(System.Boolean)">
<summary>
 Appends a text if the predicate is false
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.appendIfTrue(System.Boolean,System.String,System.Text.StringBuilder)">
<summary>
 Appends a text if the predicate is true
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.append(System.String,System.Text.StringBuilder)">
<summary>
 Appends a text
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.convertTextToWindowsLineBreaks(System.String)">
<summary>
 Converts the given text from linux or mac linebreaks to windows line breaks
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.replaceFile(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Replaces the file with the given string
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.writeStringToFile(System.Boolean,System.String,System.String)">
<summary>
 Writes a single string to a file
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.writeToFile(System.Boolean,System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Writes a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.readFile(System.String)">
<summary>
 Reads a file line by line
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.readFileAsString(System.String)">
<summary>
 Reads a file as one text
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.allFilesExist(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks if all given files exists
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.checkFileExists(System.String)">
<summary>
 Checks if the file exists on disk.
</summary>
</member>
<member name="P:FSharpx.IO.IOPrimitives.currentDirectory">
<summary>
 Gets the current directory
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.filesInDir(System.IO.DirectoryInfo)">
<summary>
 Gets all files in the directory
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.subDirectories(System.IO.DirectoryInfo)">
<summary>
 Gets all subdirectories
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.getFullName(System.String)">
<summary>
 Converts a file to it&apos;s full file system name
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.fileSystemInfo(System.String)">
<summary>
 Creates a FileInfo or a DirectoryInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.fileInfo(System.String)">
<summary>
 Creates a FileInfo for the given path
</summary>
</member>
<member name="M:FSharpx.IO.IOPrimitives.directoryInfo(System.String)">
<summary>
 Creates a DirectoryInfo for the given path
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.ToLinqExpression(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Convert the quotation expression to LINQ expression trees

 This operation will only succeed for a subset of quotation expressions.

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.EvaluateUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.Evaluate``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Evaluate the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.CompileUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluator.Compile``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.LinqExpressionHelper``1(``0)">
<summary>
 This function should not be called directly. 
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr`1.Eval``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Evaluate the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr`1.Compile``1(Microsoft.FSharp.Quotations.FSharpExpr{``0})">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.EvalUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.CompileUntyped(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Compile the quotation expression by first converting to LINQ expression trees

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="M:FSharpx.Linq.QuotationEvaluation.Expr.ToLinqExpression(Microsoft.FSharp.Quotations.FSharpExpr)">
<summary>
 Convert the quotation expression to LINQ expression trees

 This operation will only succeed for a subset of quotation expressions.

 Exceptions: InvalidArgumentException will be raised if the input expression is
 not in the subset that can be converted to a LINQ expression tree
</summary>
</member>
<member name="T:FSharpx.Linq.QuotationEvaluation.HelperTypes">
<summary>
 A set of types used for implementing quotation conversions.
 These are public only because targets of Linq Lambda expressions require them to be so
</summary>
</member>
<member name="T:FSharpx.Linq.QuotationEvaluation">
<summary>
 This module provides Compile and Eval extension members
 for F# quotation values, implemented by translating to LINQ
 expression trees and using the LINQ dynamic compiler.
</summary>
</member>
<member name="M:FSharpx.Linq.ExtraHashCompare.GenericNotEqualIntrinsic``1(``0,``0)">
<summary>
 An intrinsic for compiling &lt;c&gt;&amp;lt;@ x &lt;&gt; y @&amp;gt;&lt;/c&gt; to expression trees
</summary>
</member>
<member name="P:FSharpx.Monoid.productInt">
<summary>
 Monoid (int,1,*)
</summary>
</member>
<member name="P:FSharpx.Monoid.sumInt">
<summary>
 Monoid (int,0,+)
</summary>
</member>
<member name="M:FSharpx.Monoid.product``1">
<summary>
 Monoid (a,1,*)
</summary>
</member>
<member name="M:FSharpx.Monoid.sum``1">
<summary>
 Monoid (a,0,+)
</summary>
</member>
<member name="M:FSharpx.Monoid.dual``1(FSharpx.Monoid{``0})">
<summary>
 The dual of a monoid, obtained by swapping the arguments of &apos;Combine&apos;.
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListenerResponse.AsyncReply(System.Net.HttpListenerResponse,System.String,System.Byte[])">
<summary>
 Sends the specified data as a reply with the specified content type
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListenerResponse.AsyncReply(System.Net.HttpListenerResponse,System.String)">
<summary>
 Sends the specified string as a reply in UTF 8 encoding
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListenerRequest.get_AsyncInputString(System.Net.HttpListenerRequest)">
<summary>
 Asynchronously reads the &apos;InputStream&apos; of the request and converts it to a string
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListener.Start.Static(System.String,Microsoft.FSharp.Core.FSharpFunc{System.Tuple{System.Net.HttpListenerRequest,System.Net.HttpListenerResponse},Microsoft.FSharp.Control.FSharpAsync{Microsoft.FSharp.Core.Unit}},Microsoft.FSharp.Core.FSharpOption{System.Threading.CancellationToken})">
<summary>
 Starts HttpListener on the specified URL. The &apos;handler&apos; function is
 called (in a new thread pool thread) each time an HTTP request is received.
</summary>
</member>
<member name="M:FSharpx.Net.HttpExtensions.HttpListener.AsyncGetContext(System.Net.HttpListener)">
<summary>
 Asynchronously waits for an incoming request and returns it.
</summary>
</member>
<member name="M:FSharpx.Nullable.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Nullable{``0},System.Nullable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Nullable.toList``1(System.Nullable{``0})">
<summary>
 Convert the nullable to a list of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.toArray``1(System.Nullable{``0})">
<summary>
 Convert the nullable to an array of length 0 or 1.
</summary>
</member>
<member name="M:FSharpx.Nullable.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Nullable{``0})">
<summary>
 Transforms a Nullable value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Nullable.iter``1(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.Unit},System.Nullable{``0})">
<summary>
 Executes a function for a nullable value.
</summary>
</member>
<member name="M:FSharpx.Nullable.forall``1(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.forall for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.exists``1(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},System.Boolean},System.Nullable{``0})">
<summary>
 Evaluates the equivalent of List.exists for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.foldBack``2(Microsoft.FSharp.Core.FSharpFunc{System.Nullable{``0},Microsoft.FSharp.Core.FSharpFunc{``1,``1}},System.Nullable{``0},``1)">
<summary>
 Performs the equivalent of the List.foldBack operation on a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.fold``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0}},``0,System.Nullable{``1})">
<summary>
 Evaluates the equivalent of List.fold for a nullable.
</summary>
</member>
<member name="M:FSharpx.Nullable.count``1(System.Nullable{``0})">
<summary>
 Returns 1 if Nullable has value, otherwise 0
</summary>
</member>
<member name="M:FSharpx.Nullable.isNull``1(System.Nullable{``0})">
<summary>
 True if Nullable does not have value
</summary>
</member>
<member name="M:FSharpx.Nullable.hasValue``1(System.Nullable{``0})">
<summary>
 True if Nullable has value
</summary>
</member>
<member name="M:FSharpx.Nullable.bind``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Nullable{``1}},System.Nullable{``0})">
<summary>
 Monadic bind
</summary>
</member>
<member name="M:FSharpx.Nullable.toOption``1">
<summary>
 Converts nullable to option
</summary>
</member>
<member name="M:FSharpx.Nullable.ofOption``1">
<summary>
 Converts option to nullable
</summary>
</member>
<member name="M:FSharpx.Nullable.get``1(System.Nullable{``0})">
<summary>
 Gets the value associated with the Nullable.
 If no value, throws.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrElse``1(System.Nullable{``0},System.Lazy{``0})">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Nullable.getOrDefault``1(System.Nullable{``0},``0)">
<summary>
 Gets the value associated with the nullable or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Operators.applyM``7(``0,``5,``1,``6)">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Operators.returnM``3(``0,``1)">
<summary>
 Inject a value into the monadic type
</summary>
</member>
<member name="T:FSharpx.Operators">
<summary>
 Generic monadic operators    
</summary>
</member>
<member name="T:FSharpx.Option.MaybeBuilder">
<summary>
 The maybe monad.
 This monad is my own and uses an &apos;T option. Others generally make their own Maybe&lt;&apos;T&gt; type from Option&lt;&apos;T&gt;.
 The builder approach is from Matthew Podwysocki&apos;s excellent Creating Extended Builders series http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/18/much-ado-about-monads-creating-extended-builders.aspx.
</summary>
</member>
<member name="M:FSharpx.Option.concat``1(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpOption{``0}})">
<summary>
 Concatenates an option of option.
</summary>
</member>
<member name="M:FSharpx.Option.fromTryPattern``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Boolean,``1}},``0)">
<summary>
 transforms a function in the Try...(input, out output) style
 into a function of type: input -&gt; output Option
 Example: fromTryPattern(System.Double.TryParse)
 See Examples.Option
</summary>
</member>
<member name="M:FSharpx.Option.option``2(``0,Microsoft.FSharp.Core.FSharpFunc{``1,``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Haskell-style maybe operator
</summary>
</member>
<member name="M:FSharpx.Option.Cast``1(System.Object)">
<summary>
 Attempts to cast an object. Returns None if unsuccessful.
</summary>
</member>
<member name="M:FSharpx.Option.filter``1(Microsoft.FSharp.Core.FSharpFunc{``0,System.Boolean},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Applies a predicate to the option. If the predicate returns true, returns Some x, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.orElse``1(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the option if Some x, otherwise the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrDefault``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the default value for the type.
</summary>
</member>
<member name="M:FSharpx.Option.getOrRaise``1(System.Exception,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or raises the supplied exception.
</summary>
</member>
<member name="M:FSharpx.Option.getOrFailF``2(Microsoft.FSharp.Core.PrintfFormat{``0,Microsoft.FSharp.Core.Unit,System.String,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or print to a string buffer and raise an exception with the given result. Helper printers must return strings.
</summary>
</member>
<member name="M:FSharpx.Option.getOrFail``1(System.String,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or fails with the supplied message.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseF``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value from a function.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElseLazy``1(System.Lazy{``0},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.getOrElse``1(``0,Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Gets the value associated with the option or the supplied default value.
</summary>
</member>
<member name="M:FSharpx.Option.ofChoice``2(Microsoft.FSharp.Core.FSharpChoice{``0,``1})">
<summary>
 Maps Choice 1Of2 to Some value, otherwise None.
</summary>
</member>
<member name="M:FSharpx.Option.ofBoolAndValue``1(System.Boolean,``0)">
<summary>
 If true,value then returns Some value. Otherwise returns None.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.tryParseWith``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Tuple{System.Boolean,``1}})">
<summary>
 Converts a function returning bool,value to a function returning value option.
 Useful to process TryXX style functions.
</summary>
</member>
<member name="M:FSharpx.Option.ofBool(System.Boolean)">
<summary>
 True -&gt; Some(), False -&gt; None
</summary>
</member>
<member name="M:FSharpx.Option.toNullable``1(Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Maps an Option to Nullable
</summary>
</member>
<member name="M:FSharpx.Option.ofNullable``1(System.Nullable{``0})">
<summary>
 Maps a Nullable to Option
</summary>
</member>
<member name="M:FSharpx.Option.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpOption{``2}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequentially compose two maybe actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Option.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Option.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Option.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Option.ap``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpOption{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Option.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}},Microsoft.FSharp.Core.FSharpOption{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Option.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpOption{``0},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpOption{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Option.returnM``1(``0)">
<summary>
 Inject a value into the option type
</summary>
</member>
<member name="M:FSharpx.Option.monoid``1(FSharpx.ISemigroup{``0})">
<summary>
 Option wrapper monoid
</summary>
</member>
<member name="T:FSharpx.Reader.ReaderBuilder">
<summary>
 The reader monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/01/07/much-ado-about-monads-reader-edition.aspx.
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``2,Microsoft.FSharp.Core.FSharpFunc{``1,``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequentially compose two reader actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Reader.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,``2})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Reader.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,``0},Microsoft.FSharp.Core.FSharpFunc{``3,``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Reader.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,``0})">
<summary>
 Transforms a Reader value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Reader.ap``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``0,``1})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Reader.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``1,``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Reader.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``0,``2}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Reader.returnM``2(``0)">
<summary>
 Inject a value into the Reader type
</summary>
</member>
<member name="T:FSharpx.State.StateBuilder">
<summary>
 The state monad.
 The algorithm is adjusted from my original work off of Brian Beckman&apos;s http://channel9.msdn.com/shows/Going+Deep/Brian-Beckman-The-Zen-of-Expressing-State-The-State-Monad/.
 The approach was adjusted from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2009/12/30/much-ado-about-monads-state-edition.aspx and mirrors his final result.
</summary>
</member>
<member name="M:FSharpx.State.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``3,``2}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterDot``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.State.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.State.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``0,``3}},Microsoft.FSharp.Core.FSharpFunc{``3,System.Tuple{``1,``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.State.op_LessBangGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.State.map``3(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Transforms a State value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.State.ap``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``2},``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},``2}},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.State.op_EqualsLessLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``1,``2}}},Microsoft.FSharp.Core.FSharpFunc{``2,System.Tuple{``0,``2}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.State.op_GreaterGreaterEquals``3(Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``0,``1}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,System.Tuple{``2,``1}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.State.returnM``2(``0)">
<summary>
 Inject a value into the State type
</summary>
</member>
<member name="T:FSharpx.Stm.Core.TLog">
<summary>
 A transactional memory log
</summary>
</member>
<member name="T:FSharpx.Stm.Core.TVar`1">
<summary>
 A transactional variable 
</summary>
</member>
<member name="T:FSharpx.Stm.Core.TVar">
<summary>
 A base type for transactional variables
</summary>
</member>
<member name="T:FSharpx.Stm">
 <summary>The Software Transactional Memory monad.</summary>
 <see href="http://web.archive.org/web/20110926161739/http://cs.hubfs.net/blogs/hell_is_other_languages/archive/2008/01/16/4565.aspx" />
</member>
<member name="M:FSharpx.String.trimStart(System.Char[],System.String)">
<summary>
 Removes all leading occurrences of a set of characters specified in an array from the current String object.
</summary>
</member>
<member name="M:FSharpx.String.trimEnd(System.Char[],System.String)">
<summary>
 Removes all trailing occurrences of a set of characters specified in an array from the current String object.
</summary>
</member>
<member name="M:FSharpx.String.trim'(System.Char[],System.String)">
<summary>
 Removes all leading and trailing occurrences of a set of characters specified in an array from the current String object.
</summary>
</member>
<member name="M:FSharpx.String.trim(System.String)">
<summary>
 Removes all leading and trailing white-space characters from the current String object.
</summary>
</member>
<member name="M:FSharpx.String.toUpperInvariant(System.String)">
<summary>
 Returns a copy of this String object converted to uppercase using the casing rules of the invariant culture.
</summary>
</member>
<member name="M:FSharpx.String.toUpper'(System.Globalization.CultureInfo,System.String)">
<summary>
 Returns a copy of this string converted to uppercase, using the casing rules of the specified culture.
</summary>
</member>
<member name="M:FSharpx.String.toUpper(System.String)">
<summary>
 Returns a copy of this string converted to uppercase.
</summary>
</member>
<member name="M:FSharpx.String.toLowerInvariant(System.String)">
<summary>
 Returns a copy of this String object converted to lowercase using the casing rules of the invariant culture.
</summary>
</member>
<member name="M:FSharpx.String.toLower'(System.Globalization.CultureInfo,System.String)">
<summary>
 Returns a copy of this string converted to lowercase, using the casing rules of the specified culture.
</summary>
</member>
<member name="M:FSharpx.String.toLower(System.String)">
<summary>
 Returns a copy of this string converted to lowercase.
</summary>
</member>
<member name="M:FSharpx.String.toCharArray'(System.Int32,System.Int32,System.String)">
<summary>
 Copies the characters in a specified substring in this instance to a Unicode character array.
</summary>
</member>
<member name="M:FSharpx.String.toCharArray(System.String)">
<summary>
 Copies the characters in this instance to a Unicode character array.
</summary>
</member>
<member name="M:FSharpx.String.substring'(System.Int32,System.Int32,System.String)">
<summary>
 Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.
</summary>
</member>
<member name="M:FSharpx.String.substring(System.Int32,System.String)">
<summary>
 Retrieves a substring from this instance. The substring starts at a specified character position and continues to the end of the string.
</summary>
</member>
<member name="M:FSharpx.String.startsWith''(System.String,System.Boolean,System.Globalization.CultureInfo,System.String)">
<summary>
 Determines whether the beginning of this string instance matches the specified string when compared using the specified culture.
</summary>
</member>
<member name="M:FSharpx.String.startsWith'(System.String,System.StringComparison,System.String)">
<summary>
 Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.
</summary>
</member>
<member name="M:FSharpx.String.startsWith(System.String,System.String)">
<summary>
 Determines whether the beginning of this string instance matches the specified string.
</summary>
</member>
<member name="M:FSharpx.String.splitString'(System.String[],System.Int32,System.StringSplitOptions,System.String)">
<summary>
 Splits a string into a maximum number of substrings based on the strings in an array. You can specify whether the substrings include empty array elements.
</summary>
</member>
<member name="M:FSharpx.String.splitString(System.String[],System.StringSplitOptions,System.String)">
<summary>
 Splits a string into substrings based on the strings in an array. You can specify whether the substrings include empty array elements.
</summary>
</member>
<member name="M:FSharpx.String.splitCharWithOptions'(System.Char[],System.Int32,System.StringSplitOptions,System.String)">
<summary>
 Splits a string into a maximum number of substrings based on the characters in an array.
</summary>
</member>
<member name="M:FSharpx.String.splitCharWithOptions(System.Char[],System.StringSplitOptions,System.String)">
<summary>
 Splits a string into substrings based on the characters in an array. You can specify whether the substrings include empty array elements.
</summary>
</member>
<member name="M:FSharpx.String.splitChar'(System.Char[],System.Int32,System.String)">
<summary>
 Splits a string into a maximum number of substrings based on the characters in an array. You also specify the maximum number of substrings to return.
</summary>
</member>
<member name="M:FSharpx.String.splitChar(System.Char[],System.String)">
<summary>
 Splits a string into substrings that are based on the characters in an array.
</summary>
</member>
<member name="M:FSharpx.String.replace'(System.String,System.String,System.String)">
<summary>
 Returns a new string in which all occurrences of a specified string in the current instance are replaced with another specified string.
</summary>
</member>
<member name="M:FSharpx.String.replace(System.Char,System.Char,System.String)">
<summary>
 Returns a new string in which all occurrences of a specified Unicode character in this instance are replaced with another specified Unicode character.
</summary>
</member>
<member name="M:FSharpx.String.remove'(System.Int32,System.Int32,System.String)">
<summary>
 Returns a new string in which a specified number of characters in the current instance beginning at a specified position have been deleted.
</summary>
</member>
<member name="M:FSharpx.String.remove(System.Int32,System.String)">
<summary>
 Returns a new string in which all the characters in the current instance, beginning at a specified position and continuing through the last position, have been deleted.
</summary>
</member>
<member name="M:FSharpx.String.padRight'(System.Int32,System.Char,System.String)">
<summary>
 Returns a new string that left-aligns the characters in this string by padding them on the right with a specified Unicode character, for a specified total length.
</summary>
</member>
<member name="M:FSharpx.String.padRight(System.Int32,System.String)">
<summary>
 Returns a new string that left-aligns the characters in this string by padding them with spaces on the right, for a specified total length.
</summary>
</member>
<member name="M:FSharpx.String.padLeft'(System.Int32,System.Char,System.String)">
<summary>
 Returns a new string that right-aligns the characters in this instance by padding them on the left with a specified Unicode character, for a specified total length.
</summary>
</member>
<member name="M:FSharpx.String.padLeft(System.Int32,System.String)">
<summary>
 Returns a new string that right-aligns the characters in this instance by padding them with spaces on the left, for a specified total length.
</summary>
</member>
<member name="M:FSharpx.String.normalize'(System.Text.NormalizationForm,System.String)">
<summary>
 Returns a new string whose textual value is the same as this string, but whose binary representation is in the specified Unicode normalization form.
</summary>
</member>
<member name="M:FSharpx.String.normalize(System.String)">
<summary>
 Returns a new string whose textual value is the same as this string, but whose binary representation is in Unicode normalization form C.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfStringWithComparison''(System.String,System.Int32,System.Int32,System.StringComparison,System.String)">
<summary>
 Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for the specified number of character positions. A parameter specifies the type of comparison to perform when searching for the specified string.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfStringWithComparison'(System.String,System.Int32,System.StringComparison,System.String)">
<summary>
 Reports the zero-based index of the last occurrence of a specified string within the current String object. The search starts at a specified character position and proceeds backward toward the beginning of the string. A parameter specifies the type of comparison to perform when searching for the specified string.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfStringWithComparison(System.String,System.StringComparison,System.String)">
<summary>
 Reports the zero-based index of the last occurrence of a specified string within the current String object. A parameter specifies the type of search to use for the specified string.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfString''(System.String,System.Int32,System.Int32,System.String)">
<summary>
 Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfString'(System.String,System.Int32,System.String)">
<summary>
 Reports the zero-based index position of the last occurrence of a specified string within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfString(System.String,System.String)">
<summary>
 Reports the zero-based index position of the last occurrence of a specified string within this instance.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfChar''(System.Char,System.Int32,System.Int32,System.String)">
<summary>
 Reports the zero-based index position of the last occurrence of the specified Unicode character in a substring within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string for a specified number of character positions.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfChar'(System.Char,System.Int32,System.String)">
<summary>
 Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance. The search starts at a specified character position and proceeds backward toward the beginning of the string.
</summary>
</member>
<member name="M:FSharpx.String.lastIndexOfChar(System.Char,System.String)">
<summary>
 Reports the zero-based index position of the last occurrence of a specified Unicode character within this instance.
</summary>
</member>
<member name="M:FSharpx.String.isNormalized'(System.Text.NormalizationForm,System.String)">
<summary>
 Indicates whether this string is in the specified Unicode normalization form.
</summary>
</member>
<member name="M:FSharpx.String.isNormalized(System.String)">
<summary>
 Indicates whether this string is in Unicode normalization form C.
</summary>
</member>
<member name="M:FSharpx.String.insert(System.Int32,System.String,System.String)">
<summary>
 Returns a new string in which a specified string is inserted at a specified index position in this instance.
</summary>
</member>
<member name="M:FSharpx.String.indexOfAny''(System.Char[],System.Int32,System.Int32,System.String)">
<summary>
 Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters. The search starts at a specified character position and examines a specified number of character positions.
</summary>
</member>
<member name="M:FSharpx.String.indexOfAny'(System.Char[],System.Int32,System.String)">
<summary>
 Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters. The search starts at a specified character position.
</summary>
</member>
<member name="M:FSharpx.String.indexOfAny(System.Char[],System.String)">
<summary>
 Reports the zero-based index of the first occurrence in this instance of any character in a specified array of Unicode characters.
</summary>
</member>
<member name="M:FSharpx.String.indexOfStringWithComparison''(System.String,System.Int32,System.Int32,System.StringComparison,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified string in the current String object. Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.
</summary>
</member>
<member name="M:FSharpx.String.indexOfStringWithComparison'(System.String,System.Int32,System.StringComparison,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified string in the current String object. Parameters specify the starting search position in the current string and the type of search to use for the specified string.
</summary>
</member>
<member name="M:FSharpx.String.indexOfStringWithComparison(System.String,System.StringComparison,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified string in the current String object. A parameter specifies the type of search to use for the specified string.
</summary>
</member>
<member name="M:FSharpx.String.indexOfString''(System.String,System.Int32,System.Int32,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified string in this instance. The search starts at a specified character position and examines a specified number of character positions.
</summary>
</member>
<member name="M:FSharpx.String.indexOfString'(System.String,System.Int32,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified string in this instance. The search starts at a specified character position.
</summary>
</member>
<member name="M:FSharpx.String.indexOfString(System.String,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified string in this instance.
</summary>
</member>
<member name="M:FSharpx.String.indexOfChar''(System.Char,System.Int32,System.Int32,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified character in this instance. The search starts at a specified character position and examines a specified number of character positions.
</summary>
</member>
<member name="M:FSharpx.String.indexOfChar'(System.Char,System.Int32,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified Unicode character in this string. The search starts at a specified character position.
</summary>
</member>
<member name="M:FSharpx.String.indexOfChar(System.Char,System.String)">
<summary>
 Reports the zero-based index of the first occurrence of the specified Unicode character in this string.
</summary>
</member>
<member name="M:FSharpx.String.equalsIgnoreCase(System.String,System.String)">
<summary>
 Determines whether two specified String objects have the same value. Compare strings using ordinal (binary) sort rules and ignoring the case of the strings being compared.
</summary>
</member>
<member name="M:FSharpx.String.equals(System.StringComparison,System.String,System.String)">
<summary>
 Determines whether two specified String objects have the same value.
</summary>
</member>
<member name="M:FSharpx.String.endsWith''(System.String,System.StringComparison,System.String)">
<summary>
 Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.
</summary>
</member>
<member name="M:FSharpx.String.endsWith'(System.String,System.Boolean,System.Globalization.CultureInfo,System.String)">
<summary>
 Determines whether the end of this string instance matches the specified string when compared using the specified culture.
</summary>
</member>
<member name="M:FSharpx.String.endsWith(System.String,System.String)">
<summary>
 Determines whether the end of this string instance matches the specified string.
</summary>
</member>
<member name="M:FSharpx.String.compareIgnoreCase(System.String,System.String)">
<summary>
 Compares two specified String objects and returns an integer that indicates their relative position in the sort order. Compare strings using ordinal (binary) sort rules and ignoring the case of the strings being compared.
</summary>
</member>
<member name="M:FSharpx.String.compare(System.StringComparison,System.String,System.String)">
<summary>
 Compares two specified String objects and returns an integer that indicates their relative position in the sort order.
</summary>
</member>
<member name="M:FSharpx.String.contains(System.String,System.String)">
<summary>
 Returns a value indicating whether a specified substring occurs within this string.
</summary>
</member>
<member name="T:FSharpx.String">
<summary>
 Functional wrappers around String instance methods
</summary>
</member>
<member name="T:FSharpx.Task.Result`1.Successful">
<summary>
 Task completed successfully
</summary>
</member>
<member name="T:FSharpx.Task.Result`1.Error">
<summary>
 Unhandled exception in task
</summary>
</member>
<member name="T:FSharpx.Task.Result`1.Canceled">
<summary>
 Task was canceled
</summary>
</member>
<member name="T:FSharpx.Task.Result`1">
<summary>
 Task result
</summary>
</member>
<member name="M:FSharpx.Task.ParallelWithTrottle``1(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}}})">
<summary>
 Creates a task that executes all the given tasks.
 The paralelism is throttled, so that at most `throttle` tasks run at one time.
</summary>
</member>
<member name="M:FSharpx.Task.ParallelCatchWithTrottle``1(System.Int32,System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}}})">
<summary>
 Creates a task that executes all the given tasks.
 This function doesn&apos;t throw exceptions, but instead returns an array of Choices.
 The paralelism is throttled, so that at most `throttle` tasks run at one time.
</summary>
</member>
<member name="M:FSharpx.Task.ParallelWithTrottleCustom``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.FSharpChoice{``0,System.Exception},``1},System.Int32,System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}}})">
<summary>
 common code for ParallelCatchWithTrottle and ParallelWithTrottle
</summary>
</member>
<member name="M:FSharpx.Task.ParallelCatch``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}}})">
<summary>
 Creates a task that executes all the given tasks.
 This function doesn&apos;t throw exceptions, but instead returns an array of Choices.
</summary>
</member>
<member name="M:FSharpx.Task.Parallel``1(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Threading.Tasks.Task{``0}}})">
<summary>
 Creates a task that executes all the given tasks.
</summary>
</member>
<member name="M:FSharpx.Task.Catch``1(System.Threading.Tasks.Task{``0})">
<summary>
 Creates a task that executes a specified task.
 If this task completes successfully, then this function returns Choice1Of2 with the returned value.
 If this task raises an exception before it completes then return Choice2Of2 with the raised exception.
</summary>
</member>
<member name="M:FSharpx.Task.|AggregateExn|_|(System.Exception)">
<summary>
 Active pattern that matches on flattened inner exceptions in an AggregateException
</summary>
</member>
<member name="M:FSharpx.Task.Ignore``1(System.Threading.Tasks.Task{``0})">
<summary>
 Creates a task that runs the given task and ignores its result.
</summary>
</member>
<member name="M:FSharpx.Task.ToTaskUnit(System.Threading.Tasks.Task)">
<summary>
 Converts a Task into Task&lt;unit&gt;
</summary>
</member>
<member name="M:FSharpx.Task.op_LessMultiply``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Task.op_MultiplyGreater``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Task.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Task.op_LessMultiplyGreater``2(System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Threading.Tasks.Task{``0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Task.ap``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Task.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Task.op_LessEqualsLess``4(Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterEqualsGreater``4(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{``2,System.Threading.Tasks.Task{``3}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterGreaterDot``2(System.Threading.Tasks.Task{``0},System.Threading.Tasks.Task{``1})">
<summary>
 Sequentially compose two either actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Task.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}},System.Threading.Tasks.Task{``0})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Task.op_GreaterGreaterEquals``2(System.Threading.Tasks.Task{``0},Microsoft.FSharp.Core.FSharpFunc{``0,System.Threading.Tasks.Task{``1}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Task.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Transforms a Task&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Task.mapWithOptions``2(System.Threading.CancellationToken,System.Threading.Tasks.TaskContinuationOptions,System.Threading.Tasks.TaskScheduler,Microsoft.FSharp.Core.FSharpFunc{``0,``1},System.Threading.Tasks.Task{``0})">
<summary>
 Transforms a Task&apos;s first value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Text.RegexModule.tryMatchWithOptions(System.Text.RegularExpressions.RegexOptions,System.String,System.String)">
<summary>
flags:RegexOptions -&gt; pattern:string -&gt; input:string -&gt; Regex.ActiveMatch option
</summary>
</member>
<member name="M:FSharpx.Text.Strings.inferType(System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Checks whether all values of the sequence can be inferred to a special type
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isFloat(System.String)">
<summary>
 Checks whether the string is a float
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isInt64(System.String)">
<summary>
 Checks whether the string is an int64
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isInt(System.String)">
<summary>
 Checks whether the string is an int32
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isBool(System.String)">
<summary>
 Checks whether the string is a boolean value
</summary>
</member>
<member name="M:FSharpx.Text.Strings.niceName(System.String)">
<summary>
 Turns a string into a nice PascalCase identifier
</summary>
</member>
<member name="M:FSharpx.Text.Strings.singularize(System.String)">
<summary>
 Returns the singularized version of a noun
</summary>
</member>
<member name="M:FSharpx.Text.Strings.pluralize(System.String)">
<summary>
 Returns the pluralized version of a noun
</summary>
</member>
<member name="M:FSharpx.Text.Strings.isNullOrEmpty(System.String)">
<summary>
 Returns if the string is null or empty
</summary>
</member>
<member name="M:FSharpx.Text.Strings.joinWords(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Folds the string list by seperating entries with a single space
</summary>
</member>
<member name="M:FSharpx.Text.Strings.toWords(System.String)">
<summary>
 Splits a string based on whitespace (spaces, tabs, and newlines)
</summary>
</member>
<member name="M:FSharpx.Text.Strings.joinLines(Microsoft.FSharp.Collections.FSharpList{System.String})">
<summary>
 Creates newline seperated string from the string list
</summary>
</member>
<member name="M:FSharpx.Text.Strings.toLines(System.String)">
<summary>
 Splits a string based on newlines 
</summary>
</member>
<member name="M:FSharpx.Text.Strings.splitBy(Microsoft.FSharp.Core.FSharpFunc{System.Char,System.Boolean},System.String)">
<summary>
 Returns a sequence of strings split by the predicate    
</summary>
</member>
<member name="M:FSharpx.Text.Strings.separatedBy(System.String,System.Collections.Generic.IEnumerable{System.String})">
<summary>
 Converts a sequence of strings to a single string separated with the delimiters
</summary>
</member>
<member name="M:FSharpx.Text.Strings.split(System.Char,System.String)">
<summary>
 Splits the given string at the given delimiter
</summary>
</member>
<member name="M:FSharpx.Text.Strings.contains(System.String,System.String)">
<summary>
 Returns a value indicating whether the specified substring occurs within this string
</summary>
</member>
<member name="M:FSharpx.Text.Strings.replace(System.String,System.String,System.String)">
<summary>
 Replaces the given &quot;replacement&quot; for every occurence of the pattern in the given text 
</summary>
</member>
<member name="M:FSharpx.Text.Strings.startsWith(System.String,System.String)">
<summary>
 Checks whether the given text starts with the given prefix
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.compareTwoRuntimes``2(System.Int32,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0},System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``1})">
<summary>
 Stops the average runtime for the given functions
 Afterwards it reports it with the given descriptions
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopAndReportAvarageTime``1(System.Int32,System.String,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
 Afterwards it reports it with the given description
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopAverageTime``1(System.Int32,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the average runtime for a given function and applies it the given count
</summary>
</member>
<member name="M:FSharpx.TimeMeasurement.stopTime``1(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,``0})">
<summary>
 Stops the runtime for a given function
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apr``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.apl``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0},Microsoft.FSharp.Core.FSharpChoice{``1,`0})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.CustomValidation`1.ap``2(Microsoft.FSharp.Core.FSharpChoice{``0,`0})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.op_LessMultiply``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Validation.op_MultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}},Microsoft.FSharp.Core.FSharpChoice{``2,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Validation.lift2``4(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``3}},Microsoft.FSharp.Core.FSharpChoice{``1,FSharpx.Collections.NonEmptyList{``3}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Validation.op_LessMultiplyGreater``3(Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``0,``1},FSharpx.Collections.NonEmptyList{``2}},Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``2}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.ap``3(Microsoft.FSharp.Core.FSharpChoice{``0,FSharpx.Collections.NonEmptyList{``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Validation.apm``3(FSharpx.ISemigroup{``0})">
<summary>
 Sequential application, parameterized by semigroup
</summary>
</member>
<member name="M:FSharpx.Validation.apa``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``0,``0}},Microsoft.FSharp.Core.FSharpChoice{``1,``0},Microsoft.FSharp.Core.FSharpChoice{Microsoft.FSharp.Core.FSharpFunc{``1,``2},``0})">
<summary>
 Sequential application, parameterized by append
</summary>
</member>
<member name="T:FSharpx.Writer.WriterBuilder`1">
<summary>
 The writer monad.
 This monad comes from Matthew Podwysocki&apos;s http://codebetter.com/blogs/matthew.podwysocki/archive/2010/02/01/a-kick-in-the-monads-writer-edition.aspx.
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessEqualsLess``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Right-to-left Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterEqualsGreater``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc{``1,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``2,Microsoft.FSharp.Collections.FSharpList{System.String}}}},``0)">
<summary>
 Left-to-right Kleisli composition
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterDot``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequentially compose two state actions, discarding any value produced by the first
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiply``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.Writer.op_MultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.Writer.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessBangGreater``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Infix map
</summary>
</member>
<member name="M:FSharpx.Writer.map``2(Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Transforms a Writer value by using a specified mapping function.
</summary>
</member>
<member name="M:FSharpx.Writer.ap``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_LessMultiplyGreater``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{Microsoft.FSharp.Core.FSharpFunc{``0,``1},Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.Writer.op_EqualsLessLess``2(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}},Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}})">
<summary>
 Flipped &gt;&gt;=
</summary>
</member>
<member name="M:FSharpx.Writer.op_GreaterGreaterEquals``2(Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``0,Microsoft.FSharp.Collections.FSharpList{System.String}}},Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{Microsoft.FSharp.Core.Unit,System.Tuple{``1,Microsoft.FSharp.Collections.FSharpList{System.String}}}})">
<summary>
 Sequentially compose two actions, passing any value produced by the first as an argument to the second.
</summary>
</member>
<member name="M:FSharpx.Writer.returnM``2(FSharpx.Monoid{``0},``1,Microsoft.FSharp.Core.Unit)">
<summary>
 Inject a value into the Writer type
</summary>
</member>
<member name="M:FSharpx.ZipList.op_LessMultiply``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the second argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.op_MultiplyGreater``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Sequence actions, discarding the value of the first argument.
</summary>
</member>
<member name="M:FSharpx.ZipList.lift2``3(Microsoft.FSharp.Core.FSharpFunc{``0,Microsoft.FSharp.Core.FSharpFunc{``1,``2}},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
<summary>
 Promote a function to a monad/applicative, scanning the monadic/applicative arguments from left to right.
</summary>
</member>
<member name="M:FSharpx.ZipList.ap``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,``1}})">
<summary>
 Sequential application
</summary>
</member>
<member name="M:FSharpx.ZipList.op_LessMultiplyGreater``2(System.Collections.Generic.IEnumerable{Microsoft.FSharp.Core.FSharpFunc{``0,``1}},System.Collections.Generic.IEnumerable{``0})">
<summary>
 Sequential application
</summary>
</member>
</members>
</doc>
